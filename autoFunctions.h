#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     irSensor,       sensorHiTechnicIRSeeker600)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     firstPickupMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rightWheel,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     secondPickupMotor,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     liftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     liftMotor,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    irServo,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    clampServo,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    dropServo,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "includes.h"

///////////////////////// Global Variables //////////////////////////

float wheelSize = 14.6; // in cm
float gearRatio = 2;
float vel_curr = 0.0;
float vel_prev = 0.0;
float dt = 0.0;
int timer_gyro = 0;
float heading = 0.0;
float error;
float fullPower = 100;
bool irDetected = false;
int timeGoal = 2 * 1000;
int timeCenter = 4 * 1000;
int timeOneBall = 100;
int timeFiveBall = 2 * 1000;
int positionOneBall = 50;
int positionFiveBall = 255;
typedef enum Position {
	goal,
	center,
	down
};
Position position = down;

///////////////////////////// Function Declarations //////////////////////

// turns the robot left
void turnLeft(float degrees);
// turns the robot right
void turnRight(float degrees);
// moves the robot forward
void driveForward(float distance);
// moves the robot backward
void driveBackward(float distance);
// checks the ir sensor for the beacon
void checkIR();
// starts the pickup
void startPickup();
// reverses the pickup
void reversePickup();
// stops the pickup
void stopPickup();
// raises the lift to the goal
void raiseLift(int seconds);
// lowers the lift
void lowerLift(int seconds);
// drops the balls
void dropBall(int position, int seconds);

/////////////////////////// Task Declarations ///////////////////////////////

// starts the gyro
task a_gyro();
// rasises the ir sensor
task a_raiseIR();
// lowers the ir sensor
task a_lowerIR();
// checks to see if the ir detects the beacon
task a_readIR();
// drops the clamp for roaling goals
task a_dropClamp();
// starts the pickup
task a_startPickup();
// reverses the pickup
task a_reversePickup();
// stops the pickup
task a_stopPickup();
// raises the lift
task a_raiseLiftGoal();
// raises the lift to the center
task a_raiseLiftCenter();
// lowers the lift
task a_lowerLift();
// drops 1 ball
task a_dropOneBall();
// drops 5 balls
task a_dropFiveBall();

///////////////////////////// Function Definitions ///////////////////////////

// turns the robot to the left
void turnLeft(float degrees) {
	bool isTurning = true;
	float startOrientation = heading;
	float currentOrientation = heading;
	float target = startOrientation + degrees;
	float power, power_neg;
	float kP = 5.7;
	bool isFineTune = false;
	float finish_timer = 0.0;
	int timer_timeout = 0.0;
	float timeout_threshold = 3000.0;

	Time_ClearTimer(timer_timeout);

	while(isTurning && Time_GetTime(timer_timeout) < timeout_threshold) {
		currentOrientation = heading;
		error = target - currentOrientation;
		if(error > 60)
			power = fullPower;
		else if(error < 60)
			power = -fullPower;
		else
			power = kP * error;
		if(abs(power) < 20) {
			if(power > 0)
				power = 20;
			else if(power < 0)
				power = -20;
		}
		power_neg = -power;
		motor[leftWheel] = power_neg;
		motor[rightWheel] = power;
		if(abs(error) < 2.5) {
			if(isFineTune == false) {
				Time_ClearTimer(finish_timer);
				isFineTune = true;
			}
			else if(Time_GetTime(finish_timer) > 500)
				isTurning = false;
		}
		if(Time_GetTime(timer_timeout) > timeout_threshold) {
			isTurning = false;
			while(true) {
				Motor_SetPower(0, leftWheel);
				Motor_SetPower(0, rightWheel);
				Time_Wait(1);
			}
		}
	}

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

// turns the robot to the right
void turnRight(float degrees) {
	turnLeft(-degrees);
}

// drives the robot forward
void driveForward(float distance) {
	float target = distance / wheelSize / gearRatio / 1440 / 2 / PI; // is in revolutions
	//float kP = 0.03;
	float power = 0.0;
	bool isMoving = true;
	int timer_timeout = 0;
	int timer_threshold = 3000;
	float pos_avg;
	Time_ClearTimer(timer_timeout);

	Motor_ResetEncoder(leftWheel);
	Motor_ResetEncoder(rightWheel);

	while(isMoving) {
		pos_avg = (Motor_GetEncoder(leftWheel) - Motor_GetEncoder(rightWheel)) / 2.0;
		error = target - pos_avg;
		if(error > 0) {
			power = fullPower;
		}
		else {
			power = -fullPower;
		}

		/*if(error > 3000)
			power = fullPower;
		else if(error < -3000)
			power = -fullPower;
		else
			power = kP*error;
		if(abs(power) < 10) {
			if(power > 0)
				power = 15;
			else if(power < 0)
				power = -15;
		}*/

		motor[leftWheel] = power;
		motor[rightWheel] = power;
		if(abs(error) < 150)
			isMoving = false;
		if(Time_GetTime(timer_timeout) > timer_threshold) {
			isMoving = false;
			motor[leftWheel] = 0;
			motor[rightWheel] = 0;
		}
	}
	wait1Msec(1);
}

// moves the robot forward
void driveBackward(float distance) {
	driveForward(-distance);
}

// checks the ir sensor for the beacon
void checkIR() {
	if(SensorValue[irSensor] == 0)
		irDetected = true;
	else
		irDetected = false;
	wait1Msec(1);
}

// starts the pickup
void startPickup() {
	while(true) {
		motor[firstPickupMotor] = 100;
		motor[secondPickupMotor] = 100;
	}
	wait1Msec(1);
}

// reverses the pickup
void reversePickup() {
	while(true) {
		motor[firstPickupMotor] = -100;
		motor[secondPickupMotor] = -100;
	}
	wait1Msec(1);
}

// stops the pickup
void stopPickup() {
	motor[firstPickupMotor] = 0;
	motor[secondPickupMotor] = 0;
	wait1Msec(1);
}

// raises the lift
void raiseLift(int seconds) {
	motor[liftMotor] = 100;
	wait1Msec(seconds);
	motor[liftMotor] = 0;
}

// lowers the lift
void lowerLift(int seconds) {
	motor[liftMotor] = -100;
	wait1Msec(seconds);
	motor[liftMotor] = 0;
}

// drops one ball
void dropBall(int position, int seconds) {
	servo[dropServo] = position;
	wait1Msec(seconds);
	servo[dropServo] = 0;
}

////////////////////////////// Task Definitions ///////////////////////////

// starts the gyro
task a_gyro() {
	Time_ClearTimer(timer_gyro);
	while (true) {
		vel_prev = vel_curr;
		dt = (float)Time_GetTime(timer_gyro) /1000.0;
		Time_ClearTimer(timer_gyro);
		vel_curr = (float)HTGYROreadRot(gyroSensor);
		heading += (vel_prev+vel_curr)*0.5*dt;
		wait1Msec(1);
	}
}

// raises the ir sensor
task a_raiseIR() {
	servo[irServo] = 255;
	wait1Msec(1);
}

// lowers the ir sensor
task a_lowerIR() {
	servo[irServo] = 0;
	wait1Msec(1);
}

// checks the ir for the beacon
task a_readIR() {
	while(true) {
		checkIR();
	}
	wait1Msec(1);
}

// drops the clamp
task a_dropClamp() {
	servo[clampServo] = 120;
	wait1Msec(1);
}

// starts the pickup
task a_startPickup() {
	startPickup();
	wait1Msec(1);
}

// reverses the pickup
task a_reversePickup() {
	reversePickup();
	wait1Msec(1);
}

// stops the pickup
task a_stopPickup() {
	stopPickup();
	wait1Msec(1);
}

// raises the lift
task a_raiseLiftGoal() {
	raiseLift(timeGoal);
	position = goal;
	wait1Msec(1);
}

// raises the lift to the center
task a_raiseLiftCenter() {
	raiseLift(timeCenter);
	position = center;
	wait1Msec(1);
}

// lowers the lift
task a_lowerLift() {
	if(position == goal) {
		lowerLift(timeGoal);
	}
	if(position == center) {
		lowerLift(timeCenter);
	}
	position = down;
	wait1Msec(1);
}

// drops one ball
task a_dropOneBall() {
	dropBall(positionOneBall, timeOneBall);
	wait1Msec(1);
}

// drops five ball
task a_dropFiveBall() {
	dropBall(positionFiveBall, timeFiveBall);
	wait1Msec(1);
}
