#pragma config(Hubs,   S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     irSensor,       sensorHiTechnicIRSeeker600)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,    			tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     firstPickupMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rightWheel,    			tmotorTetrix, openLoop,	reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     liftMotor,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_1, 		secondPickupMotor,	tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     liftMotor,     			tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    irServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    clampServo,         tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    dropServo,          tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,             tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,             tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,             tServoNone)
//#pragma config(Motor,  mtr_S1_C4_1,     liftMotor,     tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "includes.h"

///////////////////////// Changable Variables //////////////////////////

const int endIRPos = 120;
const int startIRPos = 0;
const int fullPower = 100;
const int liftRaisePower = 60;
const int liftLowerPower = 40;
const int pickupPower = 35;
const int stopPower = 0;
const int startPosClamp = 0;
const int endPosClamp = 120;
const int startPosDrop = 15;
const int endPosDrop = 55;
const float d_wheelDiam = 14.6; // in cm
const float l_wheelDiam = 10.0; // in cm
const float d_circumference = d_wheelDiam * PI;
const float l_circumference = l_wheelDiam * PI;
const float d_gearRatio = 2.0;
const float l_gearRatio = 1.0;
const int distanceGoal = 60;
const int distanceCenter = 90;
const int timeOneBall = 100;
const int timeFiveBall = 2 * 1000;
const int positionOneBall = 50;
const int positionFiveBall = 255;
const static int errorCount = 5;

/////////////////////// Don't change these variables ///////////////////
float g_vel_curr = 0.0;
float d_vel_curr = 0.0;
float l_vel_curr = 0.0;
float g_vel_prev = 0.0;
float g_dt = 0.0;
float d_dt = 0.0;
float l_dt = 0.0;
float orientation = 0.0;
float d_distanceTraveled = 0.0;
float l_distanceTraveled = 0.0;
bool irDetected = false;
int timer_gyro = 0;
int timer_distance = 0;
int timer_lift = 0;
typedef enum Position {
	goal,
	center,
	down
};
Position position = down;

///////////////////////////// Function Declarations //////////////////////

// turns the robot left
void turnLeft(float degrees);
// turns the robot right
void turnRight(float degrees);
// moves the robot forward
void driveForward(float distance);
// moves the robot backward
void driveBackward(float distance);
// checks the ir sensor for the beacon
void checkIR();
// starts the pickup
void startPickup();
// reverses the pickup
void reversePickup();
// stops the pickup
void stopPickup();
// raises the lift to the goal
void raiseLift(float distance);
// lowers the lift
void lowerLift(float distance);
// drops the balls
void dropBall(int position, int seconds);

/////////////////////////// Task Declarations ///////////////////////////////

// starts the gyro
task a_gyro();
// tells how far robot has travelled
task a_wheelEncoder();
// tells where the lift is
task a_liftEncoder();
// rasises the ir sensor
task a_raiseIR();
// lowers the ir sensor
task a_lowerIR();
// checks to see if the ir detects the beacon
task a_readIR();
// drops the clamp for roaling goals
task a_dropClamp();
// starts the pickup
task a_startPickup();
// reverses the pickup
task a_reversePickup();
// stops the pickup
task a_stopPickup();
// raises the lift
task a_raiseLiftGoal();
// raises the lift to the center
task a_raiseLiftCenter();
// lowers the lift
task a_lowerLift();
// drops 1 ball
task a_dropOneBall();
// drops 5 balls
task a_dropFiveBall();

///////////////////////////// Function Definitions ///////////////////////////

// turns the robot to the left
void turnLeft(float degrees) {
	bool isTurning = true;
	int timer = 0.0;
	int power = 0.0;
	float target = orientation + degrees;
	float t_power, t_power_neg;
	float kP = 0.3;
	float kI = 10.0;
	float totalDt = 0.0;
	float currDt = 0.0;
	float PIDValue = 0.0;
	float currError = 0.0;
	float prevError = 0.0;
	float errorRate = 0.0;
	float i_error[errorCount] = {0.0,0.0,0.0,0.0,0.0};
	float i_errorValue = 0.0;
	float errorArrayValue = 0.0;

	Time_ClearTimer(timer);
	while(isTurning) {
		i_errorValue = 0.0;
		currDt = Time_GetTime(timer) / 1000 - totalDt;
		totalDt += currDt;
		prevError = currError;
		currError = target - orientation;
		errorRate = prevError - currError;
		errorArrayValue = errorRate * currDt;
		for(int i = 0; i < errorCount-2; i++) {
			i_error[i] = i_error[i+1];
		}
		i_error[4] = errorArrayValue;
		for(int i = 0; i < errorCount - 1; i++) {
			i_errorValue += i_error[i];
		}
		PIDValue = kP * currError + kI * i_errorValue;

		if(abs(PIDValue) < 2.5) {
				isTurning = false;
		}
		if(PIDValue > 50)
			t_power = fullPower;
		else if(PIDValue < 50)
			t_power = -fullPower;
		else
			power = PIDValue;
		if(abs(power) < 20) {
			if(power > 0)
				t_power = 20;
			else if(power < 0)
				t_power = -20;
		}
		t_power_neg = -power;
		motor[leftWheel] = t_power_neg;
		motor[rightWheel] = t_power;
	}
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

// turns the robot to the right
void turnRight(float degrees) {
	turnLeft(-degrees);
}

// drives the robot forward
void driveForward(float distance) {
    float target = d_distanceTraveled + (distance / d_circumference / d_gearRatio / 360);
    bool isMoving = true;
    int power = 0.0;
    int timer = 0.0;
		float d_power;
		float kP = 0.3;
		float kI = 10.0;
		float totalDt = 0.0;
		float currDt = 0.0;
		float PIDValue = 0.0;
		float currError = 0.0;
		float prevError = 0.0;
		float errorRate = 0.0;
		float i_error[errorCount] = {0.0,0.0,0.0,0.0,0.0};
		float i_errorValue = 0.0;
		float errorArrayValue = 0.0;
		Time_ClearTimer(timer);

    while(isMoving) {
    	currDt = Time_GetTime(timer) / 1000 - totalDt;
    	totalDt += currDt;
    	prevError = currError;
      currError = target - d_distanceTraveled;
      errorRate = prevError - currError;
    	errorArrayValue = errorRate * currDt;

    	for(int i = 0; i < errorCount - 2; i++) {
    		i_error[i] = i_error[i+1];
    	}
    	i_error[4] = errorArrayValue;
    	for(int i = 0; i < errorCount - 1; i++) {
    		i_errorValue += i_error[i];
    	}
    	PIDValue = kP * currError + kI * i_errorValue;

      if(PIDValue > 500) {
      	d_power = fullPower;
      }
      else if(PIDValue < -500) {
      	d_power = -fullPower;
      }
      else if(PIDValue > 150) {
        d_power = 15;
      }
      else if(PIDValue < -150) {
        d_power = -15;
      }
      motor[leftWheel] = d_power;
      motor[rightWheel] = d_power;
      if(abs(PIDValue) < 50) {
          motor[leftWheel] = 0;
          motor[rightWheel] = 0;
          isMoving = false;
      }
    }
    // motor[leftWheel] = 0;
    // motor[rightWheel] = 0;
    wait1Msec(1);
}

// moves the robot forward
void driveBackward(float distance) {
	driveForward(-distance);
}

// checks the ir sensor for the beacon
void checkIR() {
	if(SensorValue[irSensor] == 0)
		irDetected = true;
	else
		irDetected = false;
	wait1Msec(1);
}

// starts the pickup
void startPickup() {
	while(true) {
		motor[firstPickupMotor] = pickupPower;
		motor[secondPickupMotor] = pickupPower;
	}
	wait1Msec(1);
}

// reverses the pickup
void reversePickup() {
	while(true) {
		motor[firstPickupMotor] = -pickupPower;
		motor[secondPickupMotor] = -pickupPower;
	}
	wait1Msec(1);
}

// stops the pickup
void stopPickup() {
	motor[liftMotor] = 0;
	wait1Msec(1);
}

// raises the lift
void raiseLift(float distance, int maxPower) {
	float target = l_distanceTraveled + (distance / l_circumference / l_gearRatio / 360);
  bool isLifting = true;
  int power = 0.0;
  int timer = 0.0;
	float l_power;
	float kP = 0.3;
	float kI = 10.0;
	float totalDt = 0.0;
	float currDt = 0.0;
	float PIDValue = 0.0;
	float currError = 0.0;
	float prevError = 0.0;
	float errorRate = 0.0;
	float i_error[errorCount] = {0.0,0.0,0.0,0.0,0.0};
	float i_errorValue = 0.0;
	float errorArrayValue = 0.0;
	Time_ClearTimer(timer);

  while(isLifting) {
  	currDt = Time_GetTime(timer) / 1000 - totalDt;
  	totalDt += currDt;
   	prevError = currError;
    currError = target - l_distanceTraveled;
    errorRate = prevError - currError;
    errorArrayValue = errorRate * currDt;

    for(int i = 0; i < errorCount - 2; i++) {
    	i_error[i] = i_error[i+1];
    }
    i_error[4] = errorArrayValue;
    for(int i = 0; i < errorCount - 1; i++) {
    	i_errorValue += i_error[i];
    }
  	PIDValue = kP * currError + kI * i_errorValue;

		if(PIDValue > 500) {
			l_power = maxPower;
		}
		else if(PIDValue < 500) {
			l_power = -maxPower;
		}
		else if(PIDValue > 150) {
			l_power = 40;
		}
		else if(PIDValue < -150) {
			l_power = -40;
		}
		else {
			l_power = 0;
			isLifting = false;
		}
		motor[liftMotor] = l_power;
	}
	motor[liftMotor] = 0;
}

// lowers the lift
void lowerLift(float distance, int maxPower) {
	raiseLift(-distance, maxPower);
}

// drops one ball
void dropBall(int position, int seconds) {
	servo[dropServo] = endPosDrop;
	wait1Msec(seconds);
	servo[dropServo] = startPosDrop;
}

////////////////////////////// Task Definitions ///////////////////////////

// starts the gyro
task a_gyro() {
	Time_ClearTimer(timer_gyro);
	while (true) {
		g_vel_prev = g_vel_curr;
		g_dt = (float)Time_GetTime(timer_gyro) / 1000;
		Time_ClearTimer(timer_gyro);
		g_vel_curr = (float)HTGYROreadRot(gyroSensor);
		//orientation += (g_vel_prev + g_vel_curr) * 0.5 * g_dt;
		orientation += g_vel_curr * g_dt;
		wait1Msec(1);
	}
}

// Distance Travelled by robot
task a_wheeEncoder() {
	Time_ClearTimer(timer_distance);
  while(true) {
  	d_dt = (float)Time_GetTime(timer_distance) / 1000.0;
    Time_ClearTimer(timer_distance);
    d_vel_curr = (float)(Motor_GetEncoder(leftWheel) + Motor_GetEncoder(rightWheel)) / 2;
    d_distanceTraveled += d_vel_curr * d_dt;
    wait1Msec(1);
  }
}

// tells position of the lift
task a_liftEncoder() {
	Time_ClearTimer(timer_lift);
	while(true) {
		l_dt = (float)Time_GetTime(timer_lift) / 1000.0;
		Time_ClearTimer(timer_lift);
		l_vel_curr = (float)(Motor_GetEncoder(liftMotor));
		l_distanceTraveled += l_vel_curr * l_dt;
		wait1Msec(1);
	}
}

// raises the ir sensor
task a_raiseIR() {
	servo[irServo] = endIRPos;
	wait1Msec(1);
}

// lowers the ir sensor
task a_lowerIR() {
	servo[irServo] = startIRPos;
	wait1Msec(1);
}

// checks the ir for the beacon
task a_readIR() {
	while(true) {
		checkIR();
	}
	wait1Msec(1);
}

// drops the clamp
task a_dropClamp() {
	servo[clampServo] = 120;
	wait1Msec(1);
}

// starts the pickup
task a_startPickup() {
	startPickup();
	wait1Msec(1);
}

// reverses the pickup
task a_reversePickup() {
	reversePickup();
	wait1Msec(1);
}

// stops the pickup
task a_stopPickup() {
	stopPickup();
	wait1Msec(1);
}

// raises the lift
task a_raiseLiftGoal() {
	raiseLift(distanceGoal, liftRaisePower);
	position = goal;
	wait1Msec(1);
}

// raises the lift to the center
task a_raiseLiftCenter() {
	raiseLift(distanceCenter, liftRaisePower);
	position = center;
	wait1Msec(1);
}

// lowers the lift
task a_lowerLift() {
	if(position == goal) {
		lowerLift(distanceGoal, liftLowerPower);
	}
	if(position == center) {
		lowerLift(distanceCenter, liftLowerPower);
	}
	position = down;
	wait1Msec(1);
}

// drops one ball
task a_dropOneBall() {
	dropBall(positionOneBall, timeOneBall);
	wait1Msec(1);
}

// drops five ball
task a_dropFiveBall() {
	dropBall(positionFiveBall, timeFiveBall);
	wait1Msec(1);
}
