#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     pickupMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rightWheel,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Blah,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     liftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     liftMotor,     tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "includes.h"

void turnLeft(int degrees);
void turnRight(int degrees);
void driveForward(float distance);
void driveBackward(float distance);

float wheelSize = 14.6; // in cm
float vel_curr = 0.0;
float vel_prev = 0.0;
float dt = 0.0;
float timer_gyro = 0;
float heading = 0.0;
float error;

task Gyro();

task main() {
	Joystick_WaitForStart();
	Task_Spawn(Gyro);

	motor[rightWheel] = 100;
	motor[leftWheel] = 100;
	wait1Msec(1250);
	motor[rightWheel] = 0;
	motor[leftWheel] = 0;
	wait1Msec(4000);
	driveForward(40);
	turnLeft(90.0);
	turnRight(180.0);
	driveForward(20);
}

task Gyro() {
	Time_ClearTimer(timer_gyro);
	while (true) {
		vel_prev = vel_curr;
		dt = Time_GetTime(timer_gyro)/1000.0;
		Time_ClearTimer(timer_gyro);
		vel_curr = (float)HTGYROreadRot(gyroSensor);
		heading += (vel_prev+vel_curr)*0.5*dt;
		wait1Msec(1);
	}
}

void turnLeft(int degrees) {
	bool isTurning = true;
	float startOrientation = heading;
	float currentOrientation;
	float target = startOrientation + (float)degrees;
	float power, power_neg;
	float kP = 5.7;
	bool isFineTune = false;
	int finish_timer = 0;
	int timer_timeout = 0;
	int timeout_threshold = 3000;

	Time_ClearTimer(timer_timeout);

	while(isTurning && Time_GetTime(timer_timeout) < timeout_threshold) {
		currentOrientation = heading;
		error = target - currentOrientation;
		if(error > 60)
			power = g_FullPower;
		else if(error < 060)
			power = -g_FullPower;
		else
			power = kP * error;
		if(abs(power) < 20)
			if(power > 0)
				power = 20;
			else if(power < 0)
				power = -20;
		power_neg = -power;
		Motor_SetPower(power_neg, leftWheel);
		Motor_SetPower(power, rightWheel);
		if(abs(error) < 2.5) {
			if(isFineTune == false) {
				Time_ClearTimer(finish_timer);
				isFineTune = true;
			}
			else if(Time_GetTime(finish_timer) > 500)
				isTurning = false;
		}
		if(Time_GetTime(timer_timeout) > timeout_threshold) {
			isTurning = false;
			while(true) {
				Motor_SetPower(0, leftWheel);
				Motor_SetPower(0, rightWheel);
				if(!bSoundActive)
					PlaySound(soundFastUpwardTones);
				Time_Wait(1);
			}
		}
	}

	Motor_SetPower(0, leftWheel);
	Motor_SetPower(0, rightWheel);
}

void turnRight(int degrees) {
	turnLeft(-degrees);
}

void driveForward(float distance) {
	float target = distance;
	float kP = 0.03;
	float power = 0.0;
	bool isMoving = true;
	int timer_timeout = 0;
	int timer_threshold = 4000;
	float pos_avg;
	Time_ClearTimer(timer_timeout);

	Motor_ResetEncoder(leftWheel);
	Motor_ResetEncoder(rightWheel);

	while(isMoving) {
		pos_avg = (Motor_GetEncoder(leftWheel) - Motor_GetEncoder(rightWheel)) / 2.0;
		error = target - pos_avg;
		if(error > 3000)
			power = g_FullPower;
		else if(error < -3000)
			power = -g_FullPower;
		else
			power = kP*error;
		if(abs(power) < 10) {
			if(power > 0)
				power = 15;
			else if(power < 0)
				power = -15;
		}
		power = Math_Limit(power, g_FullPower);
		Motor_SetPower(power, leftWheel);
		Motor_SetPower(power, rightWheel);
		if(abs(error) < 150)
			isMoving = false;
		if(Time_GetTime(timer_timeout) > timer_threshold) {
			isMoving = false;
			while(true) {
				Motor_SetPower(0, leftWheel);
				Motor_SetPower(0, rightWheel);
				if(!bSoundActive)
					PlaySound(soundFastUpwardTones);
				Time_Wait(50);
			}
		}
	}
}

void driveBackward(float distance) {
	driveForward(-distance);
}
