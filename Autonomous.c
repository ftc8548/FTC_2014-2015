#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     leftWheel,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     liftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rightWheel,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     pickupMotor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     liftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     liftMotor,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "includes.h"

// drives robot forward
void driveForward(int seconds, int power);
// drives the robot backward
void driveBackward(int seconds, int power);
// turns the robot right
void turnRight(float c_orientation);
// turns the robot left
void turnLeft(float c_orientation);
void turnLeft(int degrees);
void turnRight(int degrees);
void driveForward(float distance);
void driveBackward(float distance);
int powerRamp = 60;
int timeRamp = 2 *1000;
int powerGround;
float wheelSize = 10;

float vel_curr = 0.0;
float vel_prev = 0.0;
float dt = 0.0;
int timer_gyro = 0;
float heading = 0.0;
float error;

task Gyro();

task main() {
	driveForward(1, 100);
	Joystick_WaitForStart();
	Task_Spawn(Gyro);

	driveForward(1, powerRamp);
	turnLeft(90.0);
	turnRight(180.0);
	driveForward(20);
}

// drives the robot forward
void driveForward(int seconds, int power) {
	motor[rightWheel] = power;
	motor[leftWheel] = power;
	wait1MSec(seconds);
	motor[rightWheel] = 0;
	motor[leftWheel] = 0;
}

// drives the robot backward
void driveBackward(int seconds, int power) {
	motor[rightWheel] = power;
	motor[leftWheel] = power;
	wait1MSec(seconds);
	motor[rightWheel] = 0;
	motor[leftWheel] = 0;
}

// turns the robot right
void turnRight(float c_orientation) {
	while(heading - c_orientation < -90.0) {
		motor[rightWheel] = -40;
		motor[leftWheel] = 40;
	}
	motor[rightWheel] = 0;
	motor[leftWheel] = 0;
}

// turns the robot left
void turnLeft(float c_orientation) {
	while(heading - c_orientation < 90.0) {
		motor[rightWheel] = 40;
		motor[leftWheel] = -40;
	}
	motor[leftWheel] = 0;
	motor[leftWheel] = 0;
}

task Gyro() {
	Time_ClearTimer(timer_gyro);
	while (true) {
		vel_prev = (float)vel_curr;
		dt = (float)Time_GetTime(timer_gyro)/(float)1000.0;
		Time_ClearTimer(timer_gyro);
		vel_curr = (float)HTGYROreadRot(gyroSensor);
		heading += ((float)vel_prev+(float)vel_curr)*(float)0.5*(float)dt;
		wait1Msec(1);
	}
}

void turnLeft(int degrees) {
	bool isTurning = true;
	float startOrientation = heading;
	float currentOrientation = heading;
	float target = startOrientation - (float)degrees;
	float power = 0.0;
	float power_neg = 0.0;
	float kP = 5.7;
	bool isFineTune = false;
	int finish_timer = 0;
	int timer_timeout = 0;
	int timeout_threshold = 3000;

	Time_ClearTimer(timer_timeout);

	while(isTurning && Time_GetTime(timer_timeout) < timeout_threshold) {
		currentOrientation = heading;
		error = target - currentOrientation;
		if(error > 60)
			power = g_FullPower;
		else if(error < 060)
			power = -g_FullPower;
		else
			power = kP * error;
		if(abs(power) < 20)
			if(power > 0)
				power = 20;
			else if(power < 0)
				power = -20;
		power_neg = -power;
		Motor_SetPower(power, leftWheel);
		Motor_SetPower(power, rightWheel);
		if(abs(error) < 2.5) {
			if(isFineTune == false) {
				Time_ClearTimer(finish_timer);
				isFineTune = true;
			}
			else if(Time_GetTime(finish_timer) > 500)
				isTurning = false;
		}
		if(Time_GetTime(timer_timeout) > timeout_threshold) {
			isTurning = false;
			while(true) {
				Motor_SetPower(0, leftWheel);
				Motor_SetPower(0, rightWheel);
				if(!bSoundActive)
					PlaySound(soundFastUpwardTones);
				Time_Wait(50);
			}
		}
	}

	Motor_SetPower(0, leftWheel);
	Motor_SetPower(0, rightWheel);
}

void turnRight(int degrees) {
	turnLeft(-degrees);
}

void driveForward(float distance) {
	float target = distance;
	float kP = 0.03;
	float power = 0.0;
	bool isMoving = true;
	int timer_timeout = 0;
	int timer_threshold = 4000;
	float pos_avg;
	Time_ClearTimer(timer_timeout);

	Motor_ResetEncoder(leftWheel);
	Motor_ResetEncoder(rightWheel);

	while(isMoving) {
		pos_avg = (Motor_GetEncoder(leftWheel) - Motor_GetEncoder(rightWheel)) / 2.0;
		error = target - pos_avg;
		if(error > 3000)
			power = g_FullPower;
		else if(error < -3000)
			power = -g_FullPower;
		else
			power = kP*error;
		if(abs(power) < 10) {
			if(power > 0)
				power = 15;
			else if(power < 0)
				power = -15;
		}
		power = Math_Limit(power, g_FullPower);
		Motor_SetPower(power, leftWheel);
		Motor_SetPower(power, rightWheel);
		if(abs(error) < 150)
			isMoving = false;
		if(Time_GetTime(timer_timeout) > timer_threshold) {
			isMoving = false;
			while(true) {
				Motor_SetPower(0, leftWheel);
				Motor_SetPower(0, rightWheel);
				if(!bSoundActive)
					PlaySound(soundFastUpwardTones);
				Time_Wait(50);
			}
		}
	}
}

void driveBackward(float distance) {
	driveForward(-distance);
}
